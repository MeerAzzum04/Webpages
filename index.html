<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml">
<meta charset="UTF-8">
<head>
   <style>
     body, html {
    margin: 0;
    padding: 0;
    height: 100%;
    font-family: 'Poppins', sans-serif;
    overflow: hidden;
  }

  body {
    display: flex;
    justify-content: center;
    align-items: center;
    background-color: #ffffff;
  }
  .text-container {
    position: absolute;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%);
    text-align: center;
    color: #000001;
    font-size: 26px;
    font-weight: 600;
    opacity: 1;
    transition: opacity 0.3s ease-in-out;
  }

  .circle {
    position: absolute;
    width: 23px;
    height: 23px;
    background-color: transparent;
    border-radius: 50%;
    transform: translate(-50%, -50%) scale(6);
    transition: width 1s ease-out, height 1s ease-out, transform 1s ease-in-out;
    pointer-events: none; /* Prevents clicking through the circle */
    display: none; /* Initially hide the circle */
  }

  .mask-circle {
    position: absolute;
    width: 23.5px;
    height: 23.5px;
    transform: translate(-50%, -50%) scale(6);
    background-color: transparent;
    border-radius: 50%;
    transition: width 1s ease-out, height 1s ease-out, transform 1s ease-in-out;
    pointer-events: none; /* Prevents clicking through the circle */
    display: none; /* Initially hide the mask circle */
  }

  .container {
    position: absolute;
    width: 100%;
    height: 100%;
    overflow: hidden;
  }

  .lottie-animation {
    position: absolute;
    width: 150px;
    height: 150px;
    transform: translate(-50%, -50%);
    pointer-events: none; /* Prevent animations from capturing touch events */
  }
    </style>
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <link href="https://fonts.googleapis.com/css2?family=Poppins:wght@400;600&display=swap" rel="stylesheet">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/lottie-web/5.7.6/lottie.min.js"></script>
</head>
<body>
  <div class="container" id="container">
    <div class="text-container" id="text">Put Fingers on the Screen to Play</div>
    <div class="circle" id="circle"></div>
    <div class="mask-circle" id="mask-circle"></div>

<script>
      // Initialize variables
    var colors = ["#284B63", "#FF0080", "#76605E", "#FDFD96", "#355b41"];
    var colorIndex = 0;
    var touchAnimations = {};
    var completedAnimation;
    var mainAnimation; // Main animation reference
    var latestPositions = {}; // To track the latest positions
    var circle;
    var maskCircle;
    var animationPath = 'https://raw.githubusercontent.com/MeerAzzum04/myjsn/main/data.json'; // Specify the path to your animation data JSON file

    // Function to shuffle colors array
    function shuffleColors(array) {
        for (let i = array.length - 1; i > 0; i--) {
            const j = Math.floor(Math.random() * (i + 1));
            [array[i], array[j]] = [array[j], array[i]];
        }
    }
    shuffleColors(colors);

    // Function to initialize main animation
    function initMainAnimation() {
        // Load animation data from path
        fetch(animationPath)
            .then(response => response.json())
            .then(data => {
                mainAnimation = data; // Assign animation data to mainAnimation
            })
            .catch(error => console.error('Error loading animation data:', error));
    }

    // Function to apply color to animation data
    function applyColorToAnimation(animationData, color) {
        animationData.layers[0].shapes[0].it[0].it[1].c.k = color; 
        animationData.layers[0].shapes[0].it[1].it[2].c.k = color;        
        animationData.layers[1].shapes[0].it[2].c.k = color; // Stroke color
        animationData.layers[1].shapes[1].it[1].c.k = color; // Stroke color
    }

    // Function to get next unique color
    function getNextColor() {
        const color = colors[colorIndex];
        colorIndex = (colorIndex + 1) % colors.length;
        // Convert hex color to "rgb(r, g, b)"
        return "rgb(" + parseInt(color.slice(1, 3), 16) + "," + parseInt(color.slice(3, 5), 16) + "," + parseInt(color.slice(5, 7), 16) + ")";
    }

    // Function to create Lottie animation
    function createAnimation(id, x, y) {
        if (Object.keys(touchAnimations).length >= 5 || touchAnimations[id]) return; // Limit to 5 touches and prevent recreation

        // Create animation container
        var container = document.createElement('div');
        container.className = 'lottie-animation';
        container.style.left = x + 'px'; // Set initial position
        container.style.top = y + 'px'; // Set initial position
        document.body.appendChild(container);

        // If main animation is not initialized, initialize it
        if (!mainAnimation) {
            initMainAnimation();
        }

        // Clone the animation data for this touch
        var animationDataCopy = JSON.parse(JSON.stringify(mainAnimation));

        // Apply unique color for this touch
        const uniqueColor = getNextColor();
        applyColorToAnimation(animationDataCopy, uniqueColor);

        // Lottie animation parameters
        var params = {
            container: container,
            renderer: 'svg',
            loop: false, // Play once
            autoplay: true,
            animationData: animationDataCopy,
            rendererSettings: {
                progressiveLoad: false
            }
        };

        // Load animation
        var anim = lottie.loadAnimation(params);
        anim.addEventListener('complete', function() {
            onAnimationComplete(anim, uniqueColor, id, x, y);
        });

        // Store animation in touchAnimations
        touchAnimations[id] = { container: container, animation: anim, x: x, y: y, completed: false };
        latestPositions[id] = { x: x, y: y }; // Store initial position
    }

    // Function to handle animation completion
    function onAnimationComplete(anim, color, id, initialX, initialY) {
        // Use the latest positions for completed animation, or initial positions if no updates
        const latestPos = latestPositions[id] || { x: initialX, y: initialY };

        // Store completed animation
        completedAnimation = { anim: anim, color: color, x: latestPos.x, y: latestPos.y };

        // Set circle and mask-circle colors and positions
        circle = document.getElementById('circle');
        maskCircle = document.getElementById('mask-circle');

        // Ensure the circle and mask-circle do not appear on initial touch point
        if (completedAnimation.x !== circle.style.left && completedAnimation.y !== circle.style.top) {
            circle.style.backgroundColor = completedAnimation.color;
            maskCircle.style.backgroundColor = "#ffffff";

            circle.style.left = completedAnimation.x + 'px';
            circle.style.top = completedAnimation.y + 'px';
            maskCircle.style.left = completedAnimation.x + 'px';
            maskCircle.style.top = completedAnimation.y + 'px';

            // Show the circle and mask-circle
            circle.style.display = 'block';
            maskCircle.style.display = 'block';

            // Circle expand transition
            setTimeout(() => {
                circle.style.transform = 'scale(200)';
            }, 500);

            // Mask circle expand transition
            setTimeout(() => {
                maskCircle.style.transform = 'scale(200)';
            }, 1000);
        }
    }

    // Function to update animation position while dragging
    function updateAnimationPosition(id, x, y) {
        if (touchAnimations[id] && !touchAnimations[id].completed) { // Only update if not completed
            var container = touchAnimations[id].container;

            container.style.left = x + 'px'; // Update position
            container.style.top = y + 'px'; // Update position

            // Update latest positions
            latestPositions[id] = { x, y };
        }
    }
    // Function to remove animation
    function removeAnimation(id) {
        if (touchAnimations[id]) {
            var container = touchAnimations[id].container;
            var anim = touchAnimations[id].animation;
            anim.destroy(); // Destroy animation instance
            document.body.removeChild(container); // Remove container
            delete touchAnimations[id];
        }
    }
    // Event listener for touch start
    document.addEventListener('touchstart', function(event) {
        event.preventDefault(); // Prevent scrolling and zooming
        var touches = event.touches;
        for (var i = 0; i < touches.length; i++) {
            if (!touchAnimations[touches[i].identifier]) {
                createAnimation(touches[i].identifier, touches[i].clientX, touches[i].clientY);
            }
        }
        // Text opacity transition
        document.getElementById('text').style.opacity = '0';
    });

    // Event listener for touch move
    document.addEventListener('touchmove', function(event) {
        event.preventDefault(); // Prevent scrolling and zooming
        var touches = event.touches;
        for (var i = 0; i < touches.length; i++) {
            updateAnimationPosition(touches[i].identifier, touches[i].clientX, touches[i].clientY);
        }
    });

</script>
</body>
</html>
